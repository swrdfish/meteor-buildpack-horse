#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

#
# Heroku buildpack for Reaction Commerce
#


### Configure environment

set -o errexit    # always exit on error
set -o pipefail   # don't ignore exit codes when piping output
set -o nounset    # fail on unset variables
unset GIT_DIR     # Avoid GIT_DIR leak from previous build steps


### Constants

DEFAULT_CACHE="node_modules bower_components"
NODE_VERSION="4.7.3"

### Configure directories

BUILD_DIR=${1:-}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}
BP_DIR=$(cd $(dirname ${0:-}); cd ..; pwd)
METEOR_VERSION=`cat "$BUILD_DIR/.meteor/release" | sed -e 's/METEOR@//'`


mkdir -p "$BUILD_DIR/.heroku/node/"
mkdir -p "$BUILD_DIR/.heroku/meteor/"
mkdir -p "$BUILD_DIR/.heroku/build/"
cd $BUILD_DIR
export PATH="$BUILD_DIR/.heroku/node/bin:$BUILD_DIR/.heroku/meteor/.meteor":$PATH


LOG_FILE=$(mktemp -t node-build-log.XXXXX)
echo "" > "$LOG_FILE"


### Load dependencies

source $BP_DIR/lib/output.sh
source $BP_DIR/lib/json.sh
source $BP_DIR/lib/failure.sh
source $BP_DIR/lib/environment.sh
source $BP_DIR/lib/binaries.sh
source $BP_DIR/lib/cache.sh
source $BP_DIR/lib/dependencies.sh


### Handle errors

handle_failure() {
  header "Build failed"
  warn_untracked_dependencies "$LOG_FILE"
  warn_angular_resolution "$LOG_FILE"
  warn_missing_devdeps "$LOG_FILE"
  warn_econnreset "$LOG_FILE"
  warn_young_yarn "$LOG_FILE"
  failure_message | output "$LOG_FILE"
}
trap 'handle_failure' ERR


### Check initial state

[ -e "$BUILD_DIR/node_modules" ] && PREBUILD=true || PREBUILD=false
# [ -f "$BUILD_DIR/yarn.lock" ] && YARN=true || YARN=false


### Failures that should be caught immediately

fail_invalid_package_json "$BUILD_DIR"
warn_prebuilt_modules "$BUILD_DIR"
warn_missing_package_json "$BUILD_DIR"


create_env() {
  write_profile "$BP_DIR" "$BUILD_DIR"
  write_export "$BP_DIR" "$BUILD_DIR"
  export_env_dir "$ENV_DIR"
  create_default_env
}


header "Creating runtime environment"
create_env # can't pipe the whole thing because piping causes subshells, preventing exports
list_node_config


install_bins() {
  warn_node_engine "$NODE_VERSION"
  install_nodejs "$NODE_VERSION" "$BUILD_DIR/.heroku/node"
  install_meteor "$METEOR_VERSION" "$BUILD_DIR/.heroku/meteor"
  # install_npm "$NPM_VERSION" "$BUILD_DIR/.heroku/node"
  warn_old_npm
}


header "Installing binaries"
install_bins


header "Installing reaction-cli"
npm install reaction-cli


header "Generate plugin import files"
"$BUILD_DIR"/node_modules/.bin/reaction plugins Load


#
# Build the meteor app!
#

cd "$BUILD_DIR"

# Determine if we have --server-only flag capability. Allow non-zero return from grep.
echo "-----> Checking if this meteor version supports --server-only"
set +e
HAS_SERVER_ONLY=`HOME="$BUILD_DIR/.heroku/meteor" meteor help build | grep -e '--server-only'`
set -e
if [ -n "$HAS_SERVER_ONLY" ] ; then
  SERVER_ONLY_FLAG='--server-only'
else
  SERVER_ONLY_FLAG=""
fi
# Remove the Android platform if we don't support the --server-only flag.  iOS
# platform gets ignored properly.
if [ -z "$SERVER_ONLY_FLAG" ]; then
  echo "-----> Attempting to remove android platform."
  HOME="$BUILD_DIR/.heroku/meteor" meteor remove-platform android || true
  echo "-----> Moving on."
fi

meteor npm install


# Now on to bundling. Don't put the bundle in $APP_CHECKOUT_DIR during
# bundling, or it will recurse, trying to bundle up its own bundling.

echo "-----> Building Meteor app with ROOT_URL: $ROOT_URL"
BUNDLE_DEST=`$BUILD_DIR/.heroku/build/"`
mkdir -p "$BUNDLE_DEST"

# The actual invocation of `meteor build`!
HOME="$BUILD_DIR/.heroku/meteor" meteor build $BUILD_OPTIONS --server $ROOT_URL $SERVER_ONLY_FLAG --directory $BUNDLE_DEST

# echo "-----> Moving built slug to $COMPILE_DIR/app"
# mv $BUNDLE_DEST/bundle "$COMPILE_DIR/app"
# rmdir $BUNDLE_DEST

# Run npm install on the built slug; only for `--production` dependencies.
echo "-----> Installing npm production dependencies on built slug"
if [ -e "$BUNDLE_DEST"/bundle/programs/server/package.json ]; then
  cd "$BUNDLE_DEST"/bundle/programs/server
  meteor npm install --production
  cd "$BUILD_DIR"
fi

#
# Environment
#
# Add an export of PATH which includes our compile dir, etc.
# echo "-----> Adding PATH environment"
# mkdir -p "$BUILD_DIR"/.profile.d
# cat > "$BUILD_DIR"/.profile.d/path.sh <<EOF
#   #!/bin/sh
#   export PATH=\$HOME/$COMPILE_DIR_SUFFIX/bin:\$PATH
#   export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:\$HOME/$COMPILE_DIR_SUFFIX/lib
# EOF

#
# Extras
#

# source scripts in 'extra' dir, if any.  Create them for custom stuff like
# binary dependencies, additional environment settings, etc.
# echo "-----> Running extras"
# for file in `ls "$BUILDPACK_DIR"/extra | sort`; do
#   . "$BUILDPACK_DIR"/extra/$file
# done


header "Build succeeded!"
summarize_build


